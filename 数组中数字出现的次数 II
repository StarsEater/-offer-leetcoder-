记录一下这个牛逼的解法

思路：将数组中的数字按照二进制写出来相加
3 5 3 3
--------
0 0 1 1
0 1 0 1
0 0 1 1
0 0 1 1
-------
比较每一位，除以3余数为0或者1,因为除了一个数其他都是3的倍数个

0 - 1 - 2
---------
00 - 01 - 10
============
n   two   one   ==>   two  one    
0    0     0           0    0
0    0     1           0    1
0    1     0           1    0
1    0     0           0    1
1    0     1           1    0
1    1     0           0    0

#n = 0  one  = one ^ n
#n = 1  one  = one ^ n
#two = one ^(n^two&one)

if two = 0:
   one = ~two & (one^n)
if two = 1:
   one = ~two & (one^n)

==> one = ~two & (one^n)
在得到的新的one的基础上得到two，将新的one视作旧的two，旧的two是做旧的one
发现只是换了个顺序，计算规则不变  two = ~one & (two&n)
0 0    0 0
0 1    1 0
1 0    0 1
0 0    1 0
0 1    0 0
1 0    0 1
31位的计算规则都一样，最后返回one的结果就可以








 
